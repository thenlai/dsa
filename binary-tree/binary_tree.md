# Binary tree（二叉树）

[TOC]

## 二叉树的定义

1. 根结点的左右两个子节点存在零个、一个或者两个
2. 左右两个子节点都是二叉树

### 二叉树的属性

1. 节点/node：
   - 子节点/children：
   - 父节点/parent：
   - 兄弟节点/sibling：
   - 根节点/root：树中没有父节点的节点。一棵树有且只有一个根结点
   - 叶节点/leaf：没有子节点的节点
2. 内节点：
3. 边：
4. 子树：
5. 空树：empty tree
6. 深度/depth，或高度/height：除去根节点以外的层数，d >= 0

### 二叉树的性质

1. 高度为h的导航树至少有 2^n 个叶子结点
2. 高度为 h>= 0 的二叉树至少有 h+1 个结点
3. 高度不超过h(h>=0)的二叉树至多有 2^{h+1} - 1 个结点
4. 含有 n>= 1个结点的二叉树的高度至多为 n -1
5. 含有 n>= 1个结点的二叉树的高度至少为log(n)，因此其高度为 Ω(log(n))

## 二叉树的分类



### 满二叉树

每个内节点都有两个孩子。

#### 满二叉树的性质

1. 高度为h的满二叉树，共有 2^(n+1) -1 个结点。

   根据 等比数列求和公式 可以证明：
   $$
   2^0 + 2^1 + ... + 2^h = 1 * \frac{1-2^{h+1}} {1-2} = 2^{h+1} - 1
   $$

2. 共有 2^h 个叶子

3. 共有 2^h - 1个内结点

   内结点数 = 总结点数 - 叶子数
   $$
   2^{h+1} - 1 - 2^h = (2*2^h - 2^h) -1 = 2^h -1
   $$
   ​

### 完全二叉树

除了最后一层叶子外的二叉树是满二叉树，最后一层叶子都连续地集中在最左边。

#### 完全二叉树的性质

1. 第h层的从左到右的第k个结点的编号为 2^h + k - 1
2. 叶子个数和内结点个数相等或者多1
3. 通过本结点的编号可以快速得到父结点、左右孩子的编号

### 平衡两叉树

树的两个子树的高度差不超过1。

### 赫夫曼树

带路径权值的树，权值越高的越靠近根。

## 二叉树遍历

二叉树的遍历方式可以分为：

  1. 深度优先遍历/递归遍历: 中序遍历、前序简历及后序遍历。
  2. 广度优先遍历：

### 中序遍历(LDR)

中序遍历的步骤(递归定义)：
  1. 如果节点为空，返回
  2. 对左子树进行中序遍历
  3. 访问根节点
  4. 对右子树进行中序遍历

用代码表示为：
```cpp
typedef struct TreeNode {
	T data;
	TreeNode * left;
	TreeNode * right;
	TreeNode * root;
} TreeNode;

void middle_order(TreeNode *node) {
	if(node->left != NULL) {
		middle_order(node->left);
	}
	visit(node->root);
	if(node->right != NULL) {
		middle_order(node->left);
	}
}
```

### 前序遍历

前序遍历的步骤(递归定义)：
  1. 如果节点为空，返回
  2. 访问根节点
  3. 对左子树进行前序遍历
  4. 对右子树进行前序遍历

### 后序遍历

后序遍历的步骤(递归定义)：
  1. 如果节点为空，返回
  2. 对左子树进行后序遍历
  3. 对右子树进行后序遍历
  4. 访问根节点

### 分层遍历

